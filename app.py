import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import sys
import os

# Add the parent directory to the path to import utils modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.normalize import normalize_data, create_normalization_df, verify_normalization
from utils.knapsack import solve_knapsack, create_dp_table_df
from utils.combinations import generate_combinations, calculate_distances, create_combinations_df

def main():
    st.set_page_config(page_title="–ú–µ—Ç–æ–¥ —ñ–¥–µ–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏ –¥–ª—è –≤–∏–±–æ—Ä—É –ø—Ä–æ—î–∫—Ç—ñ–≤", 
                       page_icon="üìä", 
                       layout="wide")
    
    st.title("–ú–µ—Ç–æ–¥ —ñ–¥–µ–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏ –¥–ª—è –≤–∏–±–æ—Ä—É –ø—Ä–æ—î–∫—Ç—ñ–≤")
    st.markdown("""
    –¶–µ–π –¥–æ–¥–∞—Ç–æ–∫ –¥–æ–ø–æ–º–∞–≥–∞—î –æ—Å–æ–±–∞–º, —è–∫—ñ –ø—Ä–∏–π–º–∞—é—Ç—å —Ä—ñ—à–µ–Ω–Ω—è, –≤–∏–±—Ä–∞—Ç–∏ –æ–ø—Ç–∏–º–∞–ª—å–Ω–∏–π –ø–æ—Ä—Ç—Ñ–µ–ª—å –ø—Ä–æ—î–∫—Ç—ñ–≤, 
    –≤—Ä–∞—Ö–æ–≤—É—é—á–∏ –∫—ñ–ª—å–∫–∞ –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤ —Ç–∞ –±—é–¥–∂–µ—Ç–Ω—ñ –æ–±–º–µ–∂–µ–Ω–Ω—è. –í—ñ–Ω –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –ú–µ—Ç–æ–¥ —ñ–¥–µ–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏ 
    –¥–ª—è –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è —Ä—ñ—à–µ–Ω—å, —â–æ –±–∞–ª–∞–Ω—Å—É—é—Ç—å —Ä—ñ–∑–Ω—ñ —Ü—ñ–ª—ñ.
    """)
    
    with st.sidebar:
        st.header("–í—Ö—ñ–¥–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏")
        
        # Budget input
        budget = st.number_input("–î–æ—Å—Ç—É–ø–Ω–∏–π –±—é–¥–∂–µ—Ç", min_value=1, value=6)
        
        # Number of projects
        num_projects = st.number_input("–ö—ñ–ª—å–∫—ñ—Å—Ç—å –ø—Ä–æ—î–∫—Ç—ñ–≤", min_value=1, max_value=200, value=4)
        
        st.subheader("–û–ø—Ü—ñ—ó –∞–Ω–∞–ª—ñ–∑—É")
        show_normalization = st.checkbox("–ü–æ–∫–∞–∑–∞—Ç–∏ –¥–µ—Ç–∞–ª—ñ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó", value=True)
        show_knapsack = st.checkbox("–ü–æ–∫–∞–∑–∞—Ç–∏ —Ä—ñ—à–µ–Ω–Ω—è –∑–∞–¥–∞—á—ñ –ø—Ä–æ —Ä—é–∫–∑–∞–∫", value=True)
        show_combinations = st.checkbox("–ü–æ–∫–∞–∑–∞—Ç–∏ –≤—Å—ñ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó", value=True)
        num_top_combinations = st.slider("–ö—ñ–ª—å–∫—ñ—Å—Ç—å –Ω–∞–π–∫—Ä–∞—â–∏—Ö –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è", 
                                         min_value=1, max_value=20, value=10)
    
    # Project data input
    st.header("–î–∞–Ω—ñ –ø—Ä–æ –ø—Ä–æ—î–∫—Ç–∏")
    
    # Allow selecting input method
    input_method = st.radio("–°–ø–æ—Å—ñ–± –≤–≤–µ–¥–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö", 
                            ["–†—É—á–Ω–µ –≤–≤–µ–¥–µ–Ω–Ω—è", "–ü—Ä–∏–∫–ª–∞–¥ –¥–∞–Ω–∏—Ö", "–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ CSV"],
                            horizontal=True)
    
    if input_method == "–†—É—á–Ω–µ –≤–≤–µ–¥–µ–Ω–Ω—è":
        col_headers = st.columns([1, 1, 1, 1])
        with col_headers[0]:
            st.markdown("**–ü—Ä–æ—î–∫—Ç**")
        with col_headers[1]:
            st.markdown("**–í–∞—Ä—Ç—ñ—Å—Ç—å**")
        with col_headers[2]:
            st.markdown("**–ü—Ä–∏–±—É—Ç–æ–∫**")
        with col_headers[3]:
            st.markdown("**–ï–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞**")
        
        # Initialize project data list
        projects = []
        
        # Create input fields for each project
        for i in range(num_projects):
            cols = st.columns([1, 1, 1, 1])
            with cols[0]:
                st.markdown(f"–ü—Ä–æ—î–∫—Ç {i+1}")
            with cols[1]:
                cost = st.number_input(f"–í–∞—Ä—Ç—ñ—Å—Ç—å {i+1}", 
                                       min_value=1, 
                                       value=20, 
                                       key=f"cost_{i}")
            with cols[2]:
                profit = st.number_input(f"–ü—Ä–∏–±—É—Ç–æ–∫ {i+1}", 
                                         min_value=0, 
                                         value=30, 
                                         key=f"profit_{i}")
            with cols[3]:
                expert = st.number_input(f"–ï–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞ {i+1}", 
                                         min_value=0, 
                                         value=40, 
                                         key=f"expert_{i}")
            
            # Add project data
            projects.append([cost, profit, expert])
                
    elif input_method == "–ü—Ä–∏–∫–ª–∞–¥ –¥–∞–Ω–∏—Ö":
        # Provide sample project data
        sample_data = {
            "–ú–∞–ª–∏–π –ø—Ä–∏–∫–ª–∞–¥ (4 –ø—Ä–æ—î–∫—Ç–∏)": [
                [2, 20, 4],  # x1
                [1, 30, 3],  # x2
                [3, 40, 2],  # x3
                [2, 20, 5]   # x4
            ]
        }
        
        selected_sample = st.selectbox("–í–∏–±–µ—Ä—ñ—Ç—å –ø—Ä–∏–∫–ª–∞–¥ –¥–∞–Ω–∏—Ö", list(sample_data.keys()))
        projects = sample_data[selected_sample]
        
        # Display the sample data
        project_df = pd.DataFrame(projects, 
                                 columns=["–í–∞—Ä—Ç—ñ—Å—Ç—å", "–ü—Ä–∏–±—É—Ç–æ–∫", "–ï–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞"],
                                 index=[f"–ü—Ä–æ—î–∫—Ç {i+1}" for i in range(len(projects))])
        st.dataframe(project_df)
        
    else:  # CSV Upload
        st.info("–ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ CSV —Ñ–∞–π–ª —ñ–∑ —Å—Ç–æ–≤–ø—Ü—è–º–∏: Cost, Profit, ExpertScore")
        
        uploaded_file = st.file_uploader("–í–∏–±–µ—Ä—ñ—Ç—å CSV —Ñ–∞–π–ª", type="csv")
        if uploaded_file is not None:
            try:
                csv_data = pd.read_csv(uploaded_file)
                required_columns = ["Cost", "Profit", "ExpertScore"]
                
                # Check if required columns exist (case-insensitive)
                has_columns = all(any(col.lower() == req.lower() for col in csv_data.columns) 
                                 for req in required_columns)
                
                if has_columns:
                    # Get the actual column names (preserving case)
                    cost_col = next(col for col in csv_data.columns 
                                   if col.lower() == "cost".lower())
                    profit_col = next(col for col in csv_data.columns 
                                     if col.lower() == "profit".lower())
                    expert_col = next(col for col in csv_data.columns 
                                     if col.lower() == "expertscore".lower())
                    
                    projects = []
                    for _, row in csv_data.iterrows():
                        projects.append([row[cost_col], row[profit_col], row[expert_col]])
                    
                    st.dataframe(csv_data)
                else:
                    st.error("CSV –ø–æ–≤–∏–Ω–µ–Ω –º—ñ—Å—Ç–∏—Ç–∏ —Å—Ç–æ–≤–ø—Ü—ñ Cost, Profit —Ç–∞ ExpertScore")
                    projects = []
            except Exception as e:
                st.error(f"–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è CSV: {e}")
                projects = []
        else:
            projects = []
    
    # Only proceed if we have project data
    if not projects:
        st.warning("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –¥–∞–Ω—ñ –ø—Ä–æ –ø—Ä–æ—î–∫—Ç–∏, —â–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏.")
        return
    
    # Run analysis when button is pressed
    if st.button("–í–∏–∫–æ–Ω–∞—Ç–∏ –∞–Ω–∞–ª—ñ–∑"):
        run_analysis(projects, budget, show_normalization, show_knapsack, 
                    show_combinations, num_top_combinations)

def run_analysis(projects, budget, show_normalization, show_knapsack, 
                show_combinations, num_top_combinations):
    """Run the complete project selection analysis"""
    
    st.header("–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –∞–Ω–∞–ª—ñ–∑—É")
    
    # Step 1: Normalize data
    norm_profits, norm_expert, norm_data = normalize_data(projects)
    
    if show_normalization:
        with st.expander("–ö—Ä–æ–∫ 1: –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–∞–Ω–∏—Ö", expanded=True):
            st.markdown("""
            –ù–∞ —Ü—å–æ–º—É –∫—Ä–æ—Ü—ñ –º–∏ –Ω–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ –º–µ—Ç–æ–¥ –µ–≤–∫–ª—ñ–¥–æ–≤–æ—ó –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó. 
            –¶–µ –∑–∞–±–µ–∑–ø–µ—á—É—î –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—ñ—Å—Ç—å –æ–±–æ—Ö –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤ (–ø—Ä–∏–±—É—Ç–∫—É —Ç–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–æ—ó –æ—Ü—ñ–Ω–∫–∏).
            
            –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Ñ–æ—Ä–º—É–ª–∞: $\\bar{a}_{ij} = \\frac{r_{ij}}{\\sqrt{\\sum_{i=1}^{m} r_{ij}^2}}$
            """)
            
            # Show normalization table
            norm_df = create_normalization_df(projects, norm_data)
            st.dataframe(norm_df, use_container_width=True)
            
            # Verify normalization
            verify_result = verify_normalization(norm_profits, norm_expert)
            
            st.markdown("**–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞:**")
            cols = st.columns(2)
            with cols[0]:
                st.markdown(f"–°—É–º–∞ –∫–≤–∞–¥—Ä–∞—Ç—ñ–≤ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏—Ö –ø—Ä–∏–±—É—Ç–∫—ñ–≤: {verify_result['profit_sum']}")
                st.markdown(f"–ú–∞—î –¥–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ 1.0: {'‚úÖ' if verify_result['profit_valid'] else '‚ùå'}")
            with cols[1]:
                st.markdown(f"–°—É–º–∞ –∫–≤–∞–¥—Ä–∞—Ç—ñ–≤ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏—Ö –µ–∫—Å–ø–µ—Ä—Ç–Ω–∏—Ö –æ—Ü—ñ–Ω–æ–∫: {verify_result['expert_sum']}")
                st.markdown(f"–ú–∞—î –¥–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ 1.0: {'‚úÖ' if verify_result['expert_valid'] else '‚ùå'}")
    
    # Step 2: Solve knapsack problems to find ideal points
    with st.expander("–ö—Ä–æ–∫ 2: –ü–æ—à—É–∫ —ñ–¥–µ–∞–ª—å–Ω–∏—Ö —Ç–æ—á–æ–∫", expanded=True):
        st.markdown("""
        –î–ª—è –∫–æ–∂–Ω–æ–≥–æ –∫—Ä–∏—Ç–µ—Ä—ñ—é –º–∏ –≤–∏—Ä—ñ—à—É—î–º–æ –∑–∞–¥–∞—á—É –ø—Ä–æ —Ä—é–∫–∑–∞–∫, —â–æ–± –∑–Ω–∞–π—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –º–æ–∂–ª–∏–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è 
        –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –±—é–¥–∂–µ—Ç–Ω–∏—Ö –æ–±–º–µ–∂–µ–Ω—å. –¶—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç—å —ñ–¥–µ–∞–ª—å–Ω—ñ (–∞–ª–µ –∑–∞–∑–≤–∏—á–∞–π –Ω–µ–¥–æ—Å—è–∂–Ω—ñ) —Ç–æ—á–∫–∏.
        """)
        
        # Solve for max profit
        profit_solution, max_profit, profit_dp, profit_path = solve_knapsack(
            projects, budget, 1)
        
        # Solve for max expert score
        expert_solution, max_expert, expert_dp, expert_path = solve_knapsack(
            projects, budget, 2)
        
        # Find normalized ideal points
        ideal_profit = sum([norm_profits[i] for i, x in enumerate(profit_solution) if x == 1])
        ideal_expert = sum([norm_expert[i] for i, x in enumerate(expert_solution) if x == 1])
        
        # Display ideal points
        cols = st.columns(2)
        with cols[0]:
            st.markdown("**–ú–∞–∫—Å–∏–º—ñ–∑–∞—Ü—ñ—è –ø—Ä–∏–±—É—Ç–∫—É:**")
            selected = ", ".join([f"x{i+1}" for i, x in enumerate(profit_solution) if x == 1])
            st.markdown(f"–í–∏–±—Ä–∞–Ω—ñ –ø—Ä–æ—î–∫—Ç–∏: {selected}")
            st.markdown(f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫: {max_profit}")
            st.markdown(f"–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è: {ideal_profit:.4f}")
            
            if show_knapsack:
                st.markdown("#### –†—ñ—à–µ–Ω–Ω—è –∑–∞–¥–∞—á—ñ –ø—Ä–æ —Ä—é–∫–∑–∞–∫ –¥–ª—è –ø—Ä–∏–±—É—Ç–∫—É")
                st.markdown("**–¢–∞–±–ª–∏—Ü—è –¥–∏–Ω–∞–º—ñ—á–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è:**")
                dp_df = create_dp_table_df(profit_dp, budget, "–ü—Ä–∏–±—É—Ç–æ–∫")
                st.dataframe(dp_df, hide_index=True)
        
        with cols[1]:
            st.markdown("**–ú–∞–∫—Å–∏–º—ñ–∑–∞—Ü—ñ—è –µ–∫—Å–ø–µ—Ä—Ç–Ω–æ—ó –æ—Ü—ñ–Ω–∫–∏:**")
            selected = ", ".join([f"x{i+1}" for i, x in enumerate(expert_solution) if x == 1])
            st.markdown(f"–í–∏–±—Ä–∞–Ω—ñ –ø—Ä–æ—î–∫—Ç–∏: {selected}")
            st.markdown(f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞: {max_expert}")
            st.markdown(f"–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è: {ideal_expert:.4f}")
            
            if show_knapsack:
                st.markdown("#### –†—ñ—à–µ–Ω–Ω—è –∑–∞–¥–∞—á—ñ –ø—Ä–æ —Ä—é–∫–∑–∞–∫ –¥–ª—è –µ–∫—Å–ø–µ—Ä—Ç–Ω–æ—ó –æ—Ü—ñ–Ω–∫–∏")
                st.markdown("**–¢–∞–±–ª–∏—Ü—è –¥–∏–Ω–∞–º—ñ—á–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è:**")
                dp_df = create_dp_table_df(expert_dp, budget, "–ï–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞")
                st.dataframe(dp_df, hide_index=True)
        
        st.markdown("**–Ü–¥–µ–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞:**")
        st.markdown(f"(–ü—Ä–∏–±—É—Ç–æ–∫, –ï–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞) = ({max_profit}, {max_expert})")
        st.markdown(f"(–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫, –ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞) = ({ideal_profit:.4f}, {ideal_expert:.4f})")
    
    # Step 3: Generate all feasible combinations
    with st.expander("–ö—Ä–æ–∫ 3: –ü–æ—à—É–∫ –Ω–∞–π–∫—Ä–∞—â–æ–≥–æ —Ä—ñ—à–µ–Ω–Ω—è", expanded=True):
        st.markdown("""
        –ú–∏ –≥–µ–Ω–µ—Ä—É—î–º–æ –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó –ø—Ä–æ—î–∫—Ç—ñ–≤, —è–∫—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å –±—é–¥–∂–µ—Ç–Ω–∏–º –æ–±–º–µ–∂–µ–Ω–Ω—è–º.
        –î–ª—è –∫–æ–∂–Ω–æ—ó –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó –æ–±—á–∏—Å–ª—é—î–º–æ –µ–≤–∫–ª—ñ–¥–æ–≤—É –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–æ —ñ–¥–µ–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏.
        –ö–æ–º–±—ñ–Ω–∞—Ü—ñ—è –∑ –Ω–∞–π–º–µ–Ω—à–æ—é –≤—ñ–¥—Å—Ç–∞–Ω–Ω—é —î –Ω–∞—à–∏–º —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏–º —Ä—ñ—à–µ–Ω–Ω—è–º.
        """)
        st.markdown("""
        –§–æ—Ä–º—É–ª–∞, —è–∫–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è –≤—ñ–¥—Å—Ç–∞–Ω—ñ –¥–æ —ñ–¥–µ–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏: $D_i=\\sqrt{\\sum_{j=1}^{m}{(r_{ij}\\ -\\ r_j^+)}^2}$
        
        –î–µ:
        - $D_i$ - –≤—ñ–¥—Å—Ç–∞–Ω—å –≤—ñ–¥ —Ä—ñ—à–µ–Ω–Ω—è $i$ –¥–æ —ñ–¥–µ–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏
        - $r_{ij}$ - –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è —Ä—ñ—à–µ–Ω–Ω—è $i$ –∑–∞ –∫—Ä–∏—Ç–µ—Ä—ñ—î–º $j$
        - $r_j^+$ - —ñ–¥–µ–∞–ª—å–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –∫—Ä–∏—Ç–µ—Ä—ñ—é $j$
        """)
        
        combinations = generate_combinations(projects, budget)
        
        # Calculate distances to ideal point
        distances = calculate_distances(
            combinations, norm_profits, norm_expert, ideal_profit, ideal_expert)
        
        # Display best solution
        best_combo, best_cost, best_profit, best_expert, best_norm_profit, best_norm_expert, best_distance = distances[0]
        
        st.markdown("**–ù–∞–π–∫—Ä–∞—â–µ —Ä—ñ—à–µ–Ω–Ω—è:**")
        selected = ", ".join([f"x{i+1}" for i, x in enumerate(best_combo) if x == 1])
        if not selected:
            selected = "–ñ–æ–¥–Ω–æ–≥–æ"
            
        st.markdown(f"–í–∏–±—Ä–∞–Ω—ñ –ø—Ä–æ—î–∫—Ç–∏: {selected}")
        st.markdown(f"–ó–∞–≥–∞–ª—å–Ω–∞ –≤–∞—Ä—Ç—ñ—Å—Ç—å: {best_cost}")
        st.markdown(f"–ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫: {best_profit}")
        st.markdown(f"–ó–∞–≥–∞–ª—å–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞: {best_expert}")
        st.markdown(f"–í—ñ–¥—Å—Ç–∞–Ω—å –¥–æ —ñ–¥–µ–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏: {best_distance:.4f}")
        
        # Show visualization of solutions
        st.markdown("**–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä—ñ—à–µ–Ω—å:**")
        
        # Create dataframe for plotting
        plot_data = []
        for combo, cost, profit, expert, norm_profit, norm_expert, distance in distances:
            combo_str = ", ".join([f"x{j+1}" for j, x in enumerate(combo) if x == 1]) or "–ñ–æ–¥–Ω–æ–≥–æ"
            is_best = (combo == best_combo)
            is_ideal_profit = (norm_profit == ideal_profit)
            is_ideal_expert = (norm_expert == ideal_expert)
            
            point_type = "–ó–≤–∏—á–∞–π–Ω–∞ —Ç–æ—á–∫–∞"
            if is_best:
                point_type = "–ù–∞–π–∫—Ä–∞—â–µ —Ä—ñ—à–µ–Ω–Ω—è"
            elif is_ideal_profit and is_ideal_expert:
                point_type = "–Ü–¥–µ–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞"
            elif is_ideal_profit:
                point_type = "–Ü–¥–µ–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫"
            elif is_ideal_expert:
                point_type = "–Ü–¥–µ–∞–ª—å–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞"
            
            plot_data.append({
                "–ö–æ–º–±—ñ–Ω–∞—Ü—ñ—è": combo_str,
                "–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫": norm_profit,
                "–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞": norm_expert,
                "–ü—Ä–∏–±—É—Ç–æ–∫": profit,
                "–ï–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞": expert,
                "–í—ñ–¥—Å—Ç–∞–Ω—å": distance,
                "–¢–∏–ø": point_type
            })
        
        plot_df = pd.DataFrame(plot_data)
        
        # Create scatter plot with Plotly
        fig = px.scatter(
            plot_df, 
            x="–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫", 
            y="–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞",
            color="–¢–∏–ø",
            symbol="–¢–∏–ø",
            hover_name="–ö–æ–º–±—ñ–Ω–∞—Ü—ñ—è",
            hover_data=["–ü—Ä–∏–±—É—Ç–æ–∫", "–ï–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞", "–í—ñ–¥—Å—Ç–∞–Ω—å"],
            title="–†—ñ—à–µ–Ω–Ω—è –≤ –ø—Ä–æ—Å—Ç–æ—Ä—ñ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏—Ö –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤",
            color_discrete_map={
                "–ù–∞–π–∫—Ä–∞—â–µ —Ä—ñ—à–µ–Ω–Ω—è": "#FF5733",
                "–Ü–¥–µ–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫": "#33A8FF",
                "–Ü–¥–µ–∞–ª—å–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞": "#33FF57",
                "–Ü–¥–µ–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞": "#9E33FF",
                "–ó–≤–∏—á–∞–π–Ω–∞ —Ç–æ—á–∫–∞": "#BEBEBE"
            },
            symbol_map={
                "–ù–∞–π–∫—Ä–∞—â–µ —Ä—ñ—à–µ–Ω–Ω—è": "star",
                "–Ü–¥–µ–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫": "diamond",
                "–Ü–¥–µ–∞–ª—å–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞": "diamond",
                "–Ü–¥–µ–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞": "circle",
                "–ó–≤–∏—á–∞–π–Ω–∞ —Ç–æ—á–∫–∞": "circle"
            },
            size_max=15
        )
        
        # Add ideal point (if not already in the solutions)
        fig.add_scatter(
            x=[ideal_profit], 
            y=[ideal_expert],
            mode="markers",
            marker=dict(color="purple", size=15, symbol="x"),
            name="–Ü–¥–µ–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞",
            hoverinfo="name"
        )
        
        # Customize layout to make the plot square
        fig.update_layout(
            xaxis_title="–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫",
            yaxis_title="–ù–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ –µ–∫—Å–ø–µ—Ä—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞",
            legend_title="–¢–∏–ø —Ä—ñ—à–µ–Ω–Ω—è",
            height=600,
            width=600,
            autosize=False,
            yaxis=dict(
            scaleanchor="x",
            scaleratio=1,
            )
        )
        
        st.plotly_chart(fig, use_container_width=False)
        
        # Show all combinations if requested
        if show_combinations:
            st.markdown(f"**–¢–æ–ø {min(num_top_combinations, len(distances))} —Ä—ñ—à–µ–Ω—å:**")
            combinations_df = create_combinations_df(distances[:num_top_combinations])
            st.dataframe(combinations_df, use_container_width=True)
            
            # Option to download full results
            csv = combinations_df.to_csv(index=False)
            st.download_button(
                label="–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ —è–∫ CSV",
                data=csv,
                file_name="project_selection_results.csv",
                mime="text/csv",
            )

if __name__ == "__main__":
    main()